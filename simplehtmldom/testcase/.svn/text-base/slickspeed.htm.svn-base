<!DOCTYPE html PUBLIC '-//W3C//DTD HTML 4.01//EN' 'http://www.w3.org/TR/html4/strict.dtd'>
<html lang="en">
 <head>
  <title>Selectors</title>
  <link href="default.css" type="text/css" rel="stylesheet">
  <link href="http://www.w3.org/StyleSheets/TR/W3C-WD.css" type="text/css" rel="stylesheet">
  <script src="jquery-1.2.3.pack.js"></script>
<script language="JavaScript" type="text/JavaScript">
	$(document).ready(function(){
		console.log($('a').size());
        /*
        $('div,p,a').each(
            function(idx) {
                console.log(this.href);
            }
        );
        */
	});
</script>
 </head>
 <body>
  <div class="head">
   <p id="p1"><a id="a1" href="http://www.w3.org/"><img height=48 alt=W3C src="http://www.w3.org/Icons/w3c_home" width=72></a>

   <h1 id="title">Selectors</h1>

   <h2>W3C Working Draft 15 December 2005</h2>

   <dl>

    <dt>This version:

    <dd><a id="a2" href="http://www.w3.org/TR/2005/WD-css3-selectors-20051215">
                 http://www.w3.org/TR/2005/WD-css3-selectors-20051215</a>

    <dt>Latest version:

    <dd><a id="a3" href="http://www.w3.org/TR/css3-selectors">
                 http://www.w3.org/TR/css3-selectors</a>

    <dt>Previous version:

    <dd><a id="a4" href="http://www.w3.org/TR/2001/CR-css3-selectors-20011113">
                 http://www.w3.org/TR/2001/CR-css3-selectors-20011113</a>

    <dt><a id="a5" name=editors-list></a>Editors:

    <dd class="vcard"><span class="fn">Daniel Glazman</span> (Invited Expert)</dd>

    <dd class="vcard"><a id="a6" lang="tr" class="url fn" href="http://www.tantek.com/">Tantek &Ccedil;elik</a> (Invited Expert)

    <dd class="vcard"><a id="a7" href="mailto:ian@hixie.ch" class="url fn">Ian Hickson</a> (<span
    class="company"><a id="a8" href="http://www.google.com/">Google</a></span>)

    <dd class="vcard"><span class="fn">Peter Linss</span> (former editor, <span class="company"><a
    id="a9" href="http://www.netscape.com/">Netscape/AOL</a></span>)

    <dd class="vcard"><span class="fn">John Williams</span> (former editor, <span class="company"><a
    id="a10" href="http://www.quark.com/">Quark, Inc.</a></span>)

   </dl>

   <p id="p2" class="copyright"><a
   id="a11" href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">
   Copyright</a> &copy; 2005 <a id="a12" href="http://www.w3.org/"><abbr
   title="World Wide Web Consortium">W3C</abbr></a><sup>&reg;</sup>
   (<a id="a13" href="http://www.csail.mit.edu/"><abbr title="Massachusetts
   Institute of Technology">MIT</abbr></a>, <a
   href="http://www.ercim.org/"><acronym title="European Research
   Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a
   href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved.  W3C
   <a
   href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
   <a
   href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>,
   <a
   href="http://www.w3.org/Consortium/Legal/copyright-documents">document
   use</a> rules apply.

   <hr title="Separator for header">

  </div>

  <h2><a name=abstract></a>Abstract</h2>

  <p id="p3"><em>Selectors</em> are patterns that match against elements in a
  tree. Selectors have been optimized for use with HTML and XML, and
  are designed to be usable in performance-critical code.</p>

  <p id="p4"><acronym title="Cascading Style Sheets">CSS</acronym> (Cascading
  Style Sheets) is a language for describing the rendering of <acronym
  title="Hypertext Markup Language">HTML</acronym> and <acronym
  title="Extensible Markup Language">XML</acronym> documents on
  screen, on paper, in speech, etc. CSS uses Selectors for binding
  style properties to elements in the document. This document
  describes extensions to the selectors defined in CSS level 2. These
  extended selectors will be used by CSS level 3.

  <p id="p5">Selectors define the following function:</p>

  <pre>expression &#x2217; element &rarr; boolean</pre>

  <p id="p6">That is, given an element and a selector, this specification
  defines whether that element matches the selector.</p>

  <p>These expressions can also be used, for instance, to select a set
  of elements, or a single element from a set of elements, by
  evaluating the expression across all the elements in a
  subtree. <acronym title="Simple Tree Transformation
  Sheets">STTS</acronym> (Simple Tree Transformation Sheets), a
  language for transforming XML trees, uses this mechanism. <a href="#refsSTTS">[STTS]</a></p>

  <h2><a name=status></a>Status of this document</h2>

  <p><em>This section describes the status of this document at the
  time of its publication. Other documents may supersede this
  document. A list of current W3C publications and the latest revision
  of this technical report can be found in the <a
  href="http://www.w3.org/TR/">W3C technical reports index at
  http://www.w3.org/TR/.</a></em></p>

  <p>This document describes the selectors that already exist in <a
  href="#refsCSS1"><abbr title="CSS level 1">CSS1</abbr></a> and <a
  href="#refsCSS21"><abbr title="CSS level 2">CSS2</abbr></a>, and
  also proposes new selectors for <abbr title="CSS level
  3">CSS3</abbr> and other languages that may need them.</p>

  <p>The CSS Working Group doesn't expect that all implementations of
  CSS3 will have to implement all selectors. Instead, there will
  probably be a small number of variants of CSS3, called profiles. For
  example, it may be that only a profile for interactive user agents
  will include all of the selectors.</p>

  <p>This specification is a last call working draft for the the <a
  href="http://www.w3.org/Style/CSS/members">CSS Working Group</a>
  (<a href="/Style/">Style Activity</a>). This
  document is a revision of the <a
  href="http://www.w3.org/TR/2001/CR-css3-selectors-20011113/">Candidate
  Recommendation dated 2001 November 13</a>, and has incorporated
  implementation feedback received in the past few years. It is
  expected that this last call will proceed straight to Proposed
  Recommendation stage since it is believed that interoperability will
  be demonstrable.</p>

  <p>All persons are encouraged to review and implement this
  specification and return comments to the (<a
  href="http://lists.w3.org/Archives/Public/www-style/">archived</a>)
  public mailing list <a
  href="http://www.w3.org/Mail/Lists.html#www-style">www-style</a>
  (see <a href="http://www.w3.org/Mail/Request">instructions</a>). W3C
  Members can also send comments directly to the CSS Working
  Group.
  The deadline for comments is 14 January 2006.</p>

  <p>This is still a draft document and may be updated, replaced, or
  obsoleted by other documents at any time. It is inappropriate to
  cite a W3C Working Draft as other than &quot;work in progress&quot;.

  <p>This document may be available in <a
  href="http://www.w3.org/Style/css3-selectors-updates/translations">translation</a>.
  The English version of this specification is the only normative
  version.

  <div class="subtoc">

   <h2><a name=contents>Table of contents</a></h2>

   <ul class="toc">
    <li class="tocline2"><a href="#context">1. Introduction</a>
     <ul>
      <li><a href="#dependencies">1.1. Dependencies</a> </li>
      <li><a href="#terminology">1.2. Terminology</a> </li>
      <li><a href="#changesFromCSS2">1.3. Changes from CSS2</a> </li>
     </ul>
    <li class="tocline2"><a href="#selectors">2. Selectors</a>
    <li class="tocline2"><a href="#casesens">3. Case sensitivity</a>
    <li class="tocline2"><a href="#selector-syntax">4. Selector syntax</a>
    <li class="tocline2"><a href="#grouping">5. Groups of selectors</a>
    <li class="tocline2"><a href="#simple-selectors">6. Simple selectors</a>
     <ul class="toc">
      <li class="tocline3"><a href="#type-selectors">6.1. Type selectors</a>
       <ul class="toc">
        <li class="tocline4"><a href="#typenmsp">6.1.1. Type selectors and namespaces</a></li>
       </ul>
      <li class="tocline3"><a href="#universal-selector">6.2. Universal selector</a>
       <ul>
        <li><a href="#univnmsp">6.2.1. Universal selector and namespaces</a></li>
       </ul>
      <li class="tocline3"><a href="#attribute-selectors">6.3. Attribute selectors</a>
       <ul class="toc">
        <li class="tocline4"><a href="#attribute-representation">6.3.1. Representation of attributes and attributes values</a>
        <li><a href="#attribute-substrings">6.3.2. Substring matching attribute selectors</a>
        <li class="tocline4"><a href="#attrnmsp">6.3.3. Attribute selectors and namespaces</a>
        <li class="tocline4"><a href="#def-values">6.3.4. Default attribute values in DTDs</a></li>
       </ul>
      <li class="tocline3"><a href="#class-html">6.4. Class selectors</a>
      <li class="tocline3"><a href="#id-selectors">6.5. ID selectors</a>
      <li class="tocline3"><a href="#pseudo-classes">6.6. Pseudo-classes</a>
       <ul class="toc">
        <li class="tocline4"><a href="#dynamic-pseudos">6.6.1. Dynamic pseudo-classes</a>
        <li class="tocline4"><a href="#target-pseudo">6.6.2. The :target pseudo-class</a>
        <li class="tocline4"><a href="#lang-pseudo">6.6.3. The :lang() pseudo-class</a>
        <li class="tocline4"><a href="#UIstates">6.6.4. UI element states pseudo-classes</a>
        <li class="tocline4"><a href="#structural-pseudos">6.6.5. Structural pseudo-classes</a>
         <ul>
          <li><a href="#root-pseudo">:root pseudo-class</a>
          <li><a href="#nth-child-pseudo">:nth-child() pseudo-class</a>
          <li><a href="#nth-last-child-pseudo">:nth-last-child()</a>
          <li><a href="#nth-of-type-pseudo">:nth-of-type() pseudo-class</a>
          <li><a href="#nth-last-of-type-pseudo">:nth-last-of-type()</a>
          <li><a href="#first-child-pseudo">:first-child pseudo-class</a>
          <li><a href="#last-child-pseudo">:last-child pseudo-class</a>
          <li><a href="#first-of-type-pseudo">:first-of-type pseudo-class</a>
          <li><a href="#last-of-type-pseudo">:last-of-type pseudo-class</a>
          <li><a href="#only-child-pseudo">:only-child pseudo-class</a>
          <li><a href="#only-of-type-pseudo">:only-of-type pseudo-class</a>
          <li><a href="#empty-pseudo">:empty pseudo-class</a></li>
         </ul>
        <li class="tocline4"><a href="#negation">6.6.7. The negation pseudo-class</a></li>
       </ul>
      </li>
     </ul>
    <li><a href="#pseudo-elements">7. Pseudo-elements</a>
     <ul>
      <li><a href="#first-line">7.1. The ::first-line pseudo-element</a>
      <li><a href="#first-letter">7.2. The ::first-letter pseudo-element</a>
      <li><a href="#UIfragments">7.3. The ::selection pseudo-element</a>
      <li><a href="#gen-content">7.4. The ::before and ::after pseudo-elements</a></li>
     </ul>
    <li class="tocline2"><a href="#combinators">8. Combinators</a>
     <ul class="toc">
      <li class="tocline3"><a href="#descendant-combinators">8.1. Descendant combinators</a>
      <li class="tocline3"><a href="#child-combinators">8.2. Child combinators</a>
      <li class="tocline3"><a href="#sibling-combinators">8.3. Sibling combinators</a>
       <ul class="toc">
        <li class="tocline4"><a href="#adjacent-sibling-combinators">8.3.1. Adjacent sibling combinator</a>
        <li class="tocline4"><a href="#general-sibling-combinators">8.3.2. General sibling combinator</a></li>
       </ul>
      </li>
     </ul>
    <li class="tocline2"><a href="#specificity">9. Calculating a selector's specificity</a>
    <li class="tocline2"><a href="#w3cselgrammar">10. The grammar of Selectors</a>
     <ul class="toc">
      <li class="tocline3"><a href="#grammar">10.1. Grammar</a>
      <li class="tocline3"><a href="#lex">10.2. Lexical scanner</a></li>
     </ul>
    <li class="tocline2"><a href="#downlevel">11. Namespaces and down-level clients</a>
    <li class="tocline2"><a href="#profiling">12. Profiles</a>
    <li><a href="#Conformance">13. Conformance and requirements</a>
    <li><a href="#Tests">14. Tests</a>
    <li><a href="#ACKS">15. Acknowledgements</a>
    <li class="tocline2"><a href="#references">16. References</a>
   </ul>

  </div>

  <h2><a name=context>1. Introduction</a></h2>

  <h3><a name=dependencies></a>1.1. Dependencies</h3>

  <p>Some features of this specification are specific to CSS, or have
  particular limitations or rules specific to CSS. In this
  specification, these have been described in terms of CSS2.1. <a
  href="#refsCSS21">[CSS21]</a></p>

  <h3><a name=terminology></a>1.2. Terminology</h3>

  <p>All of the text of this specification is normative except
  examples, notes, and sections explicitly marked as
  non-normative.</p>

  <h3><a name=changesFromCSS2></a>1.3. Changes from CSS2</h3>
 
  <p><em>This section is non-normative.</em></p>

  <p>The main differences between the selectors in CSS2 and those in
  Selectors are:

  <ul>

   <li>the list of basic definitions (selector, group of selectors,
   simple selector, etc.) has been changed; in particular, what was
   referred to in CSS2 as a simple selector is now called a sequence
   of simple selectors, and the term "simple selector" is now used for
   the components of this sequence</li>

   <li>an optional namespace component is now allowed in type element
   selectors, the universal selector and attribute selectors</li>

   <li>a <a href="#general-sibling-combinators">new combinator</a> has been introduced</li>

   <li>new simple selectors including substring matching attribute
   selectors, and new pseudo-classes</li>

   <li>new pseudo-elements, and introduction of the "::" convention
   for pseudo-elements</li>

   <li>the grammar has been rewritten</li>

   <li>profiles to be added to specifications integrating Selectors
   and defining the set of selectors which is actually supported by
   each specification</li>

   <li>Selectors are now a CSS3 Module and an independent
   specification; other specifications can now refer to this document
   independently of CSS</li>

   <li>the specification now has its own test suite</li>

  </ul>

<h2><a name=selectors></a>2. Selectors</h2>

<p><em>This section is non-normative, as it merely summarizes the
following sections.</em></p>

<p>A Selector represents a structure. This structure can be used as a
condition (e.g. in a CSS rule) that determines which elements a
selector matches in the document tree, or as a flat description of the
HTML or XML fragment corresponding to that structure.</p>

<p>Selectors may range from simple element names to rich contextual
representations.</p>

<p>The following table summarizes the Selector syntax:</p>

<table class="selectorsReview">
  <thead>
  <tr>
    <th class="pattern">Pattern</th>
    <th class="meaning">Meaning</th>
    <th class="described">Described in section</th>
    <th class="origin">First defined in CSS level</th></tr>
  <tbody>
  <tr>
    <td class="pattern">*</td>
    <td class="meaning">any element</td>
    <td class="described"><a
      href="#universal-selector">Universal
      selector</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E</td>
    <td class="meaning">an element of type E</td>
    <td class="described"><a
      href="#type-selectors">Type selector</a></td>
    <td class="origin">1</td></tr>
  <tr>
    <td class="pattern">E[foo]</td>
    <td class="meaning">an E element with a "foo" attribute</td>
    <td class="described"><a
      href="#attribute-selectors">Attribute
      selectors</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E[foo="bar"]</td>
    <td class="meaning">an E element whose "foo" attribute value is exactly
      equal to "bar"</td>
    <td class="described"><a
      href="#attribute-selectors">Attribute
      selectors</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E[foo~="bar"]</td>
    <td class="meaning">an E element whose "foo" attribute value is a list of
      space-separated values, one of which is exactly equal to "bar"</td>
    <td class="described"><a
      href="#attribute-selectors">Attribute
      selectors</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E[foo^="bar"]</td>
    <td class="meaning">an E element whose "foo" attribute value begins exactly
      with the string "bar"</td>
    <td class="described"><a
      href="#attribute-selectors">Attribute
      selectors</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E[foo$="bar"]</td>
    <td class="meaning">an E element whose "foo" attribute value ends exactly
      with the string "bar"</td>
    <td class="described"><a
      href="#attribute-selectors">Attribute
      selectors</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E[foo*="bar"]</td>
    <td class="meaning">an E element whose "foo" attribute value contains the
      substring "bar"</td>
    <td class="described"><a
      href="#attribute-selectors">Attribute
      selectors</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E[hreflang|="en"]</td>
    <td class="meaning">an E element whose "hreflang" attribute has a hyphen-separated
      list of values beginning (from the left) with "en"</td>
    <td class="described"><a
      href="#attribute-selectors">Attribute
      selectors</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E:root</td>
    <td class="meaning">an E element, root of the document</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:nth-child(n)</td>
    <td class="meaning">an E element, the n-th child of its parent</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:nth-last-child(n)</td>
    <td class="meaning">an E element, the n-th child of its parent, counting
      from the last one</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:nth-of-type(n)</td>
    <td class="meaning">an E element, the n-th sibling of its type</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:nth-last-of-type(n)</td>
    <td class="meaning">an E element, the n-th sibling of its type, counting
      from the last one</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:first-child</td>
    <td class="meaning">an E element, first child of its parent</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E:last-child</td>
    <td class="meaning">an E element, last child of its parent</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:first-of-type</td>
    <td class="meaning">an E element, first sibling of its type</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:last-of-type</td>
    <td class="meaning">an E element, last sibling of its type</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:only-child</td>
    <td class="meaning">an E element, only child of its parent</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:only-of-type</td>
    <td class="meaning">an E element, only sibling of its type</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:empty</td>
    <td class="meaning">an E element that has no children (including text
    nodes)</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:link<br>E:visited</td>
    <td class="meaning">an E element being the source anchor of a hyperlink of
      which the target is not yet visited (:link) or already visited
    (:visited)</td>
    <td class="described"><a
      href="#link">The link
      pseudo-classes</a></td>
    <td class="origin">1</td></tr>
  <tr>
    <td class="pattern">E:active<br>E:hover<br>E:focus</td>
    <td class="meaning">an E element during certain user actions</td>
    <td class="described"><a
      href="#useraction-pseudos">The user
      action pseudo-classes</a></td>
    <td class="origin">1 and 2</td></tr>
  <tr>
    <td class="pattern">E:target</td>
    <td class="meaning">an E element being the target of the referring URI</td>
    <td class="described"><a
      href="#target-pseudo">The target
      pseudo-class</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:lang(fr)</td>
    <td class="meaning">an element of type E in language "fr" (the document
      language specifies how language is determined)</td>
    <td class="described"><a
      href="#lang-pseudo">The :lang()
      pseudo-class</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E:enabled<br>E:disabled</td>
    <td class="meaning">a user interface element E which is enabled or
    disabled</td>
    <td class="described"><a
      href="#UIstates">The UI element states
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:checked<!--<br>E:indeterminate--></td>
    <td class="meaning">a user interface element E which is checked<!-- or in an
      indeterminate state--> (for instance a radio-button or checkbox)</td>
    <td class="described"><a
      href="#UIstates">The UI element states
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E::first-line</td>
    <td class="meaning">the first formatted line of an E element</td>
    <td class="described"><a
      href="#first-line">The ::first-line
      pseudo-element</a></td>
    <td class="origin">1</td></tr>
  <tr>
    <td class="pattern">E::first-letter</td>
    <td class="meaning">the first formatted letter of an E element</td>
    <td class="described"><a
      href="#first-letter">The ::first-letter
      pseudo-element</a></td>
    <td class="origin">1</td></tr>
  <tr>
    <td class="pattern">E::selection</td>
    <td class="meaning">the portion of an E element that is currently
      selected/highlighted by the user</td>
    <td class="described"><a
      href="#UIfragments">The UI element
      fragments pseudo-elements</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E::before</td>
    <td class="meaning">generated content before an E element</td>
    <td class="described"><a
      href="#gen-content">The ::before
      pseudo-element</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E::after</td>
    <td class="meaning">generated content after an E element</td>
    <td class="described"><a
      href="#gen-content">The ::after
      pseudo-element</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E.warning</td>
    <td class="meaning">an E element whose class is
"warning" (the document language specifies how class is determined).</td>
    <td class="described"><a
      href="#class-html">Class
    selectors</a></td>
    <td class="origin">1</td></tr>
  <tr>
    <td class="pattern">E#myid</td>
    <td class="meaning">an E element with ID equal to "myid".</td>
    <td class="described"><a
      href="#id-selectors">ID
    selectors</a></td>
    <td class="origin">1</td></tr>
  <tr>
    <td class="pattern">E:not(s)</td>
    <td class="meaning">an E element that does not match simple selector s</td>
    <td class="described"><a
      href="#negation">Negation
      pseudo-class</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E F</td>
    <td class="meaning">an F element descendant of an E element</td>
    <td class="described"><a
      href="#descendant-combinators">Descendant
      combinator</a></td>
    <td class="origin">1</td></tr>
  <tr>
    <td class="pattern">E &gt; F</td>
    <td class="meaning">an F element child of an E element</td>
    <td class="described"><a
      href="#child-combinators">Child
      combinator</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E + F</td>
    <td class="meaning">an F element immediately preceded by an E element</td>
    <td class="described"><a
      href="#adjacent-sibling-combinators">Adjacent sibling combinator</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E ~ F</td>
    <td class="meaning">an F element preceded by an E element</td>
    <td class="described"><a
      href="#general-sibling-combinators">General sibling combinator</a></td>
    <td class="origin">3</td></tr></tbody></table>

<p>The meaning of each selector is derived from the table above by
prepending "matches" to the contents of each cell in the "Meaning"
column.</p>

<h2><a name=casesens>3. Case sensitivity</a></h2>

<p>The case sensitivity of document language element names, attribute
names, and attribute values in selectors depends on the document
language. For example, in HTML, element names are case-insensitive,
but in XML, they are case-sensitive.</p>

<h2><a name=selector-syntax>4. Selector syntax</a></h2>

<p>A <dfn><a name=selector>selector</a></dfn> is a chain of one
or more <a href="#sequence">sequences of simple selectors</a>
separated by <a href="#combinators">combinators</a>.</p>

<p>A <dfn><a name=sequence>sequence of simple selectors</a></dfn>
is a chain of <a href="#simple-selectors-dfn">simple selectors</a>
that are not separated by a <a href="#combinators">combinator</a>. It
always begins with a <a href="#type-selectors">type selector</a> or a
<a href="#universal-selector">universal selector</a>. No other type
selector or universal selector is allowed in the sequence.</p>

<p>A <dfn><a name=simple-selectors-dfn></a><a
href="#simple-selectors">simple selector</a></dfn> is either a <a
href="#type-selectors">type selector</a>, <a
href="#universal-selector">universal selector</a>, <a
href="#attribute-selectors">attribute selector</a>, <a
href="#class-html">class selector</a>, <a
href="#id-selectors">ID selector</a>, <a
href="#content-selectors">content selector</a>, or <a
href="#pseudo-classes">pseudo-class</a>. One <a
href="#pseudo-elements">pseudo-element</a> may be appended to the last
sequence of simple selectors.</p>

<p><dfn>Combinators</dfn> are: white space, &quot;greater-than
sign&quot; (U+003E, <code>&gt;</code>), &quot;plus sign&quot; (U+002B,
<code>+</code>) and &quot;tilde&quot; (U+007E, <code>~</code>).  White
space may appear between a combinator and the simple selectors around
it. <a name=whitespace></a>Only the characters "space" (U+0020), "tab"
(U+0009), "line feed" (U+000A), "carriage return" (U+000D), and "form
feed" (U+000C) can occur in white space. Other space-like characters,
such as "em-space" (U+2003) and "ideographic space" (U+3000), are
never part of white space.</p>

<p>The elements of a document tree that are represented by a selector
are the <dfn><a name=subject></a>subjects of the selector</dfn>. A
selector consisting of a single sequence of simple selectors
represents any element satisfying its requirements. Prepending another
sequence of simple selectors and a combinator to a sequence imposes
additional matching constraints, so the subjects of a selector are
always a subset of the elements represented by the last sequence of
simple selectors.</p>

<p>An empty selector, containing no sequence of simple selectors and
no pseudo-element, is an <a href="#Conformance">invalid
selector</a>.</p>

<h2><a name=grouping>5. Groups of selectors</a></h2>

<p>When several selectors share the same declarations, they may be
grouped into a comma-separated list. (A comma is U+002C.)</p>

<div class="example">
<p>CSS examples:</p>
<p>In this example, we condense three rules with identical
declarations into one. Thus,</p>
<pre>h1 { font-family: sans-serif }
h2 { font-family: sans-serif }
h3 { font-family: sans-serif }</pre>
<p>is equivalent to:</p>
<pre>h1, h2, h3 { font-family: sans-serif }</pre>
</div>

<p><strong>Warning</strong>: the equivalence is true in this example
because all the selectors are valid selectors. If just one of these
selectors were invalid, the entire group of selectors would be
invalid. This would invalidate the rule for all three heading
elements, whereas in the former case only one of the three individual
heading rules would be invalidated.</p>


<h2><a name=simple-selectors>6. Simple selectors</a></h2>

<h3><a name=type-selectors>6.1. Type selector</a></h3>

<p>A <dfn>type selector</dfn> is the name of a document language
element type. A type selector represents an instance of the element
type in the document tree.</p>

<div class="example">
 <p>Example:</p>
 <p>The following selector represents an <code>h1</code> element in the document tree:</p>
 <pre>h1</pre>
</div>


<h4><a name=typenmsp>6.1.1. Type selectors and namespaces</a></h4>

<p>Type selectors allow an optional namespace (<a
href="#refsXMLNAMES">[XMLNAMES]</a>) component. A namespace prefix
that has been previously declared may be prepended to the element name
separated by the namespace separator &quot;vertical bar&quot;
(U+007C, <code>|</code>).</p>

<p>The namespace component may be left empty to indicate that the
selector is only to represent elements with no declared namespace.</p>

<p>An asterisk may be used for the namespace prefix, indicating that
the selector represents elements in any namespace (including elements
with no namespace).</p>

<p>Element type selectors that have no namespace component (no
namespace separator), represent elements without regard to the
element's namespace (equivalent to "<code>*|</code>") unless a default
namespace has been declared. If a default namespace has been declared,
the selector will represent only elements in the default
namespace.</p>

<p>A type selector containing a namespace prefix that has not been
previously declared is an <a href="#Conformance">invalid</a> selector.
The mechanism for declaring a namespace prefix is left up to the
language implementing Selectors. In CSS, such a mechanism is defined
in the General Syntax module.</p>

<p>In a namespace-aware client, element type selectors will only match
against the <a
href="http://www.w3.org/TR/REC-xml-names/#NT-LocalPart">local part</a>
of the element's <a
href="http://www.w3.org/TR/REC-xml-names/#ns-qualnames">qualified
name</a>. See <a href="#downlevel">below</a> for notes about matching
behaviors in down-level clients.</p>

<p>In summary:</p>

<dl>
  <dt><code>ns|E</code></dt>
  <dd>elements with name E in namespace ns</dd>
  <dt><code>*|E</code></dt>
  <dd>elements with name E in any namespace, including those without any
  declared namespace</dd>
  <dt><code>|E</code></dt>
  <dd>elements with name E without any declared namespace</dd>
  <dt><code>E</code></dt>
  <dd>if no default namespace has been specified, this is equivalent to *|E.
  Otherwise it is equivalent to ns|E where ns is the default namespace.</dd>
</dl>

<div class="example">
 <p>CSS examples:</p>

 <pre>@namespace foo url(http://www.example.com);
 foo|h1 { color: blue }
 foo|* { color: yellow }
 |h1 { color: red }
 *|h1 { color: green }
 h1 { color: green }</pre>

 <p>The first rule will match only <code>h1</code> elements in the
 "http://www.example.com" namespace.</p>

 <p>The second rule will match all elements in the
 "http://www.example.com" namespace.</p>

 <p>The third rule will match only <code>h1</code> elements without
 any declared namespace.</p>

 <p>The fourth rule will match <code>h1</code> elements in any
 namespace (including those without any declared namespace).</p>

 <p>The last rule is equivalent to the fourth rule because no default
 namespace has been defined.</p>

</div>

<h3><a name=universal-selector>6.2. Universal selector</a> </h3>

<p>The <dfn>universal selector</dfn>, written &quot;asterisk&quot;
(<code>*</code>), represents the qualified name of any element
type. It represents any single element in the document tree in any
namespace (including those without any declared namespace) if no
default namespace has been specified. If a default namespace has been
specified, see <a href="#univnmsp">Universal selector and
Namespaces</a> below.</p>

<p>If the universal selector is not the only component of a sequence
of simple selectors, the <code>*</code> may be omitted.</p>

<div class="example">
 <p>Examples:</p>
 <ul>
  <li><code>*[hreflang|=en]</code> and <code>[hreflang|=en]</code> are equivalent,</li>
  <li><code>*.warning</code> and <code>.warning</code> are equivalent,</li>
  <li><code>*#myid</code> and <code>#myid</code> are equivalent.</li>
 </ul>
</div>

<p class="note"><strong>Note:</strong> it is recommended that the
<code>*</code>, representing the universal selector, not be
omitted.</p>

<h4><a name=univnmsp>6.2.1. Universal selector and namespaces</a></h4>

<p>The universal selector allows an optional namespace component. It
is used as follows:</p>

<dl>
 <dt><code>ns|*</code></dt>
 <dd>all elements in namespace ns</dd>
 <dt><code>*|*</code></dt>
 <dd>all elements</dd>
 <dt><code>|*</code></dt>
 <dd>all elements without any declared namespace</dd>
 <dt><code>*</code></dt>
 <dd>if no default namespace has been specified, this is equivalent to *|*.
 Otherwise it is equivalent to ns|* where ns is the default namespace.</dd>
</dl>

<p>A universal selector containing a namespace prefix that has not
been previously declared is an <a href="#Conformance">invalid</a>
selector.  The mechanism for declaring a namespace prefix is left up
to the language implementing Selectors.  In CSS, such a mechanism is
defined in the General Syntax module.</p>


<h3><a name=attribute-selectors>6.3. Attribute selectors</a></h3>

<p>Selectors allow the representation of an element's attributes. When
a selector is used as an expression to match against an element,
attribute selectors must be considered to match an element if that
element has an attribute that matches the attribute represented by the
attribute selector.</p>

<h4><a name=attribute-representation>6.3.1. Attribute presence and values
selectors</a></h4>

<p>CSS2 introduced four attribute selectors:</p>

<dl>
  <dt><code>[att]</code>
  <dd>Represents an element with the <code>att</code> attribute, whatever the value of
  the attribute.</dd>
  <dt><code>[att=val]</code></dt>
  <dd>Represents an element with the <code>att</code> attribute whose value is exactly
  "val".</dd>
  <dt><code>[att~=val]</code></dt>
  <dd>Represents an element with the <code>att</code> attribute whose value is a <a
  href="#whitespace">whitespace</a>-separated list of words, one of
  which is exactly "val". If "val" contains whitespace, it will never
  represent anything (since the words are <em>separated</em> by
  spaces).</dd>
  <dt><code>[att|=val]</code>
  <dd>Represents an element with the <code>att</code> attribute, its value either
  being exactly "val" or beginning with "val" immediately followed by
  "-" (U+002D).  This is primarily intended to allow language subcode
  matches (e.g., the <code>hreflang</code> attribute on the
  <code>link</code> element in HTML) as described in RFC 3066 (<a
  href="#refsRFC3066">[RFC3066]</a>).  For <code>lang</code> (or
  <code>xml:lang</code>) language subcode matching, please see <a
  href="#lang-pseudo">the <code>:lang</code> pseudo-class</a>.</dd>
</dl>

<p>Attribute values must be identifiers or strings. The
case-sensitivity of attribute names and values in selectors depends on
the document language.</p>

<div class="example">

  <p>Examples:</p>

  <p>The following attribute selector represents an <code>h1</code>
  element that carries the <code>title</code> attribute, whatever its
  value:</p>

  <pre>h1[title]</pre>

  <p>In the following example, the selector represents a
  <code>span</code> element whose <code>class</code> attribute has
  exactly the value "example":</p>

  <pre>span[class="example"]</pre>

  <p>Multiple attribute selectors can be used to represent several
  attributes of an element, or several conditions on the same
  attribute. Here, the selector represents a <code>span</code> element
  whose <code>hello</code> attribute has exactly the value "Cleveland"
  and whose <code>goodbye</code> attribute has exactly the value
  "Columbus":</p>

  <pre>span[hello="Cleveland"][goodbye="Columbus"]</pre>

  <p>The following selectors illustrate the differences between "="
  and "~=".  The first selector will represent, for example, the value
  "copyright copyleft copyeditor" on a <code>rel</code> attribute. The
  second selector will only represent an <code>a</code> element with
  an <code>href</code> attribute having the exact value
  "http://www.w3.org/".</p>

  <pre>a[rel~="copyright"]
a[href="http://www.w3.org/"]</pre>

  <p>The following selector represents a <code>link</code> element
  whose <code>hreflang</code> attribute is exactly "fr".</p>

  <pre>link[hreflang=fr]</pre>

  <p>The following selector represents a <code>link</code> element for
  which the values of the <code>hreflang</code> attribute begins with
  "en", including "en", "en-US", and "en-cockney":</p>

  <pre>link[hreflang|="en"]</pre>

  <p>Similarly, the following selectors represents a
  <code>DIALOGUE</code> element whenever it has one of two different
  values for an attribute <code>character</code>:</p>

  <pre>DIALOGUE[character=romeo]
DIALOGUE[character=juliet]</pre>

</div>

<h4><a name=attribute-substrings></a>6.3.2. Substring matching attribute
selectors</h4>

<p>Three additional attribute selectors are provided for matching
substrings in the value of an attribute:</p>

<dl>
  <dt><code>[att^=val]</code></dt>
  <dd>Represents an element with the <code>att</code> attribute whose value begins
  with the prefix "val".</dd>
  <dt><code>[att$=val]</code>
  <dd>Represents an element with the <code>att</code> attribute whose value ends with
  the suffix "val".</dd>
  <dt><code>[att*=val]</code>
  <dd>Represents an element with the <code>att</code> attribute whose value contains
  at least one instance of the substring "val".</dd>
</dl>

<p>Attribute values must be identifiers or strings. The
case-sensitivity of attribute names in selectors depends on the
document language.</p>

<div class="example">
 <p>Examples:</p>
 <p>The following selector represents an HTML <code>object</code>, referencing an
 image:</p>
 <pre>object[type^="image/"]</pre>
 <p>The following selector represents an HTML anchor <code>a</code> with an
 <code>href</code> attribute whose value ends with ".html".</p>
 <pre>a[href$=".html"]</pre>
 <p>The following selector represents an HTML paragraph with a <code>title</code>
 attribute whose value contains the substring "hello"</p>
 <pre>p[title*="hello"]</pre>
</div>

<h4><a name=attrnmsp>6.3.3. Attribute selectors and namespaces</a></h4>

<p>Attribute selectors allow an optional namespace component to the
attribute name. A namespace prefix that has been previously declared
may be prepended to the attribute name separated by the namespace
separator &quot;vertical bar&quot; (<code>|</code>). In keeping with
the Namespaces in the XML recommendation, default namespaces do not
apply to attributes, therefore attribute selectors without a namespace
component apply only to attributes that have no declared namespace
(equivalent to "<code>|attr</code>"). An asterisk may be used for the
namespace prefix indicating that the selector is to match all
attribute names without regard to the attribute's namespace.

<p>An attribute selector with an attribute name containing a namespace
prefix that has not been previously declared is an <a
href="#Conformance">invalid</a> selector.  The mechanism for declaring
a namespace prefix is left up to the language implementing Selectors.
In CSS, such a mechanism is defined in the General Syntax module.

<div class="example">
  <p>CSS examples:</p>
  <pre>@namespace foo "http://www.example.com";
[foo|att=val] { color: blue }
[*|att] { color: yellow }
[|att] { color: green }
[att] { color: green }</pre>

  <p>The first rule will match only elements with the attribute
  <code>att</code> in the "http://www.example.com" namespace with the
  value "val".</p>

  <p>The second rule will match only elements with the attribute
  <code>att</code> regardless of the namespace of the attribute
  (including no declared namespace).</p>

  <p>The last two rules are equivalent and will match only elements
  with the attribute <code>att</code> where the attribute is not
  declared to be in a namespace.</p>

</div>

<h4><a name=def-values>6.3.4. Default attribute values in DTDs</a></h4>

<p>Attribute selectors represent explicitly set attribute values in
the document tree. Default attribute values may be defined in a DTD or
elsewhere, but cannot always be selected by attribute
selectors. Selectors should be designed so that they work even if the
default values are not included in the document tree.</p>

<p>More precisely, a UA is <em>not</em> required to read an "external
subset" of the DTD but <em>is</em> required to look for default
attribute values in the document's "internal subset." (See <a
href="#refsXML10">[XML10]</a> for definitions of these subsets.)</p>

<p>A UA that recognizes an XML namespace <a
href="#refsXMLNAMES">[XMLNAMES]</a> is not required to use its
knowledge of that namespace to treat default attribute values as if
they were present in the document. (For example, an XHTML UA is not
required to use its built-in knowledge of the XHTML DTD.)</p>

<p class="note"><strong>Note:</strong> Typically, implementations
choose to ignore external subsets.</p>

<div class="example">
<p>Example:</p>

<p>Consider an element EXAMPLE with an attribute "notation" that has a
default value of "decimal". The DTD fragment might be</p>

<pre class="dtd-example">&lt;!ATTLIST EXAMPLE notation (decimal,octal) "decimal"></pre>

<p>If the style sheet contains the rules</p>

<pre>EXAMPLE[notation=decimal] { /*... default property settings ...*/ }
EXAMPLE[notation=octal]   { /*... other settings...*/ }</pre>

<p>the first rule will not match elements whose "notation" attribute
is set by default, i.e. not set explicitly. To catch all cases, the
attribute selector for the default value must be dropped:</p>

<pre>EXAMPLE                   { /*... default property settings ...*/ }
EXAMPLE[notation=octal]   { /*... other settings...*/ }</pre>

<p>Here, because the selector <code>EXAMPLE[notation=octal]</code> is
more specific than the tag
selector alone, the style declarations in the second rule will override
those in the first for elements that have a "notation" attribute value
of "octal". Care has to be taken that all property declarations that
are to apply only to the default case are overridden in the non-default
cases' style rules.</p>

</div>

<h3><a name=class-html>6.4. Class selectors</a></h3>

<p>Working with HTML, authors may use the period (U+002E,
<code>.</code>) notation as an alternative to the <code>~=</code>
notation when representing the <code>class</code> attribute. Thus, for
HTML, <code>div.value</code> and <code>div[class~=value]</code> have
the same meaning. The attribute value must immediately follow the
&quot;period&quot; (<code>.</code>).</p>

<p>UAs may apply selectors using the period (.) notation in XML
documents if the UA has namespace-specific knowledge that allows it to
determine which attribute is the &quot;class&quot; attribute for the
respective namespace. One such example of namespace-specific knowledge
is the prose in the specification for a particular namespace (e.g. SVG
1.0 <a href="#refsSVG">[SVG]</a> describes the <a
href="http://www.w3.org/TR/2001/PR-SVG-20010719/styling.html#ClassAttribute">SVG
&quot;class&quot; attribute</a> and how a UA should interpret it, and
similarly MathML 1.01 <a href="#refsMATH">[MATH]</a> describes the <a
href="http://www.w3.org/1999/07/REC-MathML-19990707/chapter2.html#sec2.3.4">MathML
&quot;class&quot; attribute</a>.)</p>

<div class="example">
 <p>CSS examples:</p>

 <p>We can assign style information to all elements with
 <code>class~="pastoral"</code> as follows:</p>

  <pre>*.pastoral { color: green }  /* all elements with class~=pastoral */</pre>

  <p>or just</p>

  <pre>.pastoral { color: green }  /* all elements with class~=pastoral */</pre>

  <p>The following assigns style only to H1 elements with
  <code>class~="pastoral"</code>:</p>

  <pre>H1.pastoral { color: green }  /* H1 elements with class~=pastoral */</pre>

  <p>Given these rules, the first H1 instance below would not have
  green text, while the second would:</p>

  <pre>&lt;H1&gt;Not green&lt;/H1&gt;
&lt;H1 class="pastoral"&gt;Very green&lt;/H1&gt;</pre>

</div>

<p>To represent a subset of "class" values, each value must be preceded
by a ".", in any order.</P>

<div class="example">

  <p>CSS example:</p>

  <p>The following rule matches any P element whose "class" attribute
  has been assigned a list of <a
  href="#whitespace">whitespace</a>-separated values that includes
  "pastoral" and "marine":</p>

  <pre>p.pastoral.marine { color: green }</pre>

  <p>This rule matches when <code>class="pastoral blue aqua
  marine"</code> but does not match for <code>class="pastoral
  blue"</code>.</p>

</div>

<p class="note"><strong>Note:</strong> Because CSS gives considerable
power to the "class" attribute, authors could conceivably design their
own "document language" based on elements with almost no associated
presentation (such as DIV and SPAN in HTML) and assigning style
information through the "class" attribute.  Authors should avoid this
practice since the structural elements of a document language often
have recognized and accepted meanings and author-defined classes may
not.</p>

<p class="note"><strong>Note:</strong> If an element has multiple
class attributes, their values must be concatenated with spaces
between the values before searching for the class. As of this time the
working group is not aware of any manner in which this situation can
be reached, however, so this behavior is explicitly non-normative in
this specification.</p>

<h3><a name=id-selectors>6.5. ID selectors</a></h3>

<p>Document languages may contain attributes that are declared to be
of type ID. What makes attributes of type ID special is that no two
such attributes can have the same value in a document, regardless of
the type of the elements that carry them; whatever the document
language, an ID typed attribute can be used to uniquely identify its
element. In HTML all ID attributes are named "id"; XML applications
may name ID attributes differently, but the same restriction
applies.</p>

<p>An ID-typed attribute of a document language allows authors to
assign an identifier to one element instance in the document tree. W3C
ID selectors represent an element instance based on its identifier. An
ID selector contains a &quot;number sign&quot; (U+0023,
<code>#</code>) immediately followed by the ID value, which must be an
identifier.</p>

<p>Selectors does not specify how a UA knows the ID-typed attribute of
an element. The UA may, e.g., read a document's DTD, have the
information hard-coded or ask the user.

<div class="example">
  <p>Examples:</p>
  <p>The following ID selector represents an <code>h1</code> element
  whose ID-typed attribute has the value "chapter1":</p>
  <pre>h1#chapter1</pre>
  <p>The following ID selector represents any element whose ID-typed
  attribute has the value "chapter1":</p>
  <pre>#chapter1</pre>
  <p>The following selector represents any element whose ID-typed
  attribute has the value "z98y".</p>
  <pre>*#z98y</pre>
</div>

<p class="note"><strong>Note.</strong> In XML 1.0 <a
href="#refsXML10">[XML10]</a>, the information about which attribute
contains an element's IDs is contained in a DTD or a schema. When
parsing XML, UAs do not always read the DTD, and thus may not know
what the ID of an element is (though a UA may have namespace-specific
knowledge that allows it to determine which attribute is the ID
attribute for that namespace). If a style sheet designer knows or
suspects that a UA may not know what the ID of an element is, he
should use normal attribute selectors instead:
<code>[name=p371]</code> instead of <code>#p371</code>.  Elements in
XML 1.0 documents without a DTD do not have IDs at all.</p>

<p>If an element has multiple ID attributes, all of them must be
treated as IDs for that element for the purposes of the ID
selector. Such a situation could be reached using mixtures of xml:id,
DOM3 Core, XML DTDs, and namespace-specific knowledge.</p>

<h3><a name=pseudo-classes>6.6. Pseudo-classes</a></h3>

<p>The pseudo-class concept is introduced to permit selection based on
information that lies outside of the document tree or that cannot be
expressed using the other simple selectors.</p>

<p>A pseudo-class always consists of a &quot;colon&quot;
(<code>:</code>) followed by the name of the pseudo-class and
optionally by a value between parentheses.</p>

<p>Pseudo-classes are allowed in all sequences of simple selectors
contained in a selector. Pseudo-classes are allowed anywhere in
sequences of simple selectors, after the leading type selector or
universal selector (possibly omitted). Pseudo-class names are
case-insensitive. Some pseudo-classes are mutually exclusive, while
others can be applied simultaneously to the same
element. Pseudo-classes may be dynamic, in the sense that an element
may acquire or lose a pseudo-class while a user interacts with the
document.</p>


<h4><a name=dynamic-pseudos>6.6.1. Dynamic pseudo-classes</a></h4>

<p>Dynamic pseudo-classes classify elements on characteristics other
than their name, attributes, or content, in principle characteristics
that cannot be deduced from the document tree.</p>

<p>Dynamic pseudo-classes do not appear in the document source or
document tree.</p>


<h5>The <a name=link>link pseudo-classes: :link and :visited</a></h5>

<p>User agents commonly display unvisited links differently from
previously visited ones. Selectors
provides the pseudo-classes <code>:link</code> and
<code>:visited</code> to distinguish them:</p>

<ul>
  <li>The <code>:link</code> pseudo-class applies to links that have
  not yet been visited.</li>
  <li>The <code>:visited</code> pseudo-class applies once the link has
  been visited by the user. </li>
</ul>

<p>After some amount of time, user agents may choose to return a
visited link to the (unvisited) ':link' state.</p>

<p>The two states are mutually exclusive.</p>

<div class="example">

  <p>Example:</p>

  <p>The following selector represents links carrying class
  <code>external</code> and already visited:</p>

  <pre>a.external:visited</pre>

</div>

<p class="note"><strong>Note:</strong> It is possible for style sheet
authors to abuse the :link and :visited pseudo-classes to determine
which sites a user has visited without the user's consent.

<p>UAs may therefore treat all links as unvisited links, or implement
other measures to preserve the user's privacy while rendering visited
and unvisited links differently.</p>

<h5>The <a name=useraction-pseudos>user action pseudo-classes
:hover, :active, and :focus</a></h5>

<p>Interactive user agents sometimes change the rendering in response
to user actions. Selectors provides
three pseudo-classes for the selection of an element the user is
acting on.</p>

<ul>

  <li>The <code>:hover</code> pseudo-class applies while the user
  designates an element with a pointing device, but does not activate
  it. For example, a visual user agent could apply this pseudo-class
  when the cursor (mouse pointer) hovers over a box generated by the
  element. User agents not that do not support <a
  href="http://www.w3.org/TR/REC-CSS2/media.html#interactive-media-group">interactive
  media</a> do not have to support this pseudo-class. Some conforming
  user agents that support <a
  href="http://www.w3.org/TR/REC-CSS2/media.html#interactive-media-group">interactive
  media</a> may not be able to support this pseudo-class (e.g., a pen
  device that does not detect hovering).</li>

  <li>The <code>:active</code> pseudo-class applies while an element
  is being activated by the user. For example, between the times the
  user presses the mouse button and releases it.</li>

  <li>The <code>:focus</code> pseudo-class applies while an element
  has the focus (accepts keyboard or mouse events, or other forms of
  input). </li>

</ul>

<p>There may be document language or implementation specific limits on
which elements can become <code>:active</code> or acquire
<code>:focus</code>.</p>

<p>These pseudo-classes are not mutually exclusive. An element may
match several pseudo-classes at the same time.</p>

<p>Selectors doesn't define if the parent of an element that is
':active' or ':hover' is also in that state.</p>

<div class="example">
  <p>Examples:</p>
  <pre>a:link    /* unvisited links */
a:visited /* visited links */
a:hover   /* user hovers */
a:active  /* active links */</pre>
  <p>An example of combining dynamic pseudo-classes:</p>
  <pre>a:focus
a:focus:hover</pre>
  <p>The last selector matches <code>a</code> elements that are in
  the pseudo-class :focus and in the pseudo-class :hover.</p>
</div>

<p class="note"><strong>Note:</strong> An element can be both ':visited'
and ':active' (or ':link' and ':active').</p>

<h4><a name=target-pseudo>6.6.2. The target pseudo-class :target</a></h4>

<p>Some URIs refer to a location within a resource. This kind of URI
ends with a &quot;number sign&quot; (#) followed by an anchor
identifier (called the fragment identifier).</p>

<p>URIs with fragment identifiers link to a certain element within the
document, known as the target element. For instance, here is a URI
pointing to an anchor named <code>section_2</code> in an HTML
document:</p>

<pre>http://example.com/html/top.html#section_2</pre>

<p>A target element can be represented by the <code>:target</code>
pseudo-class. If the document's URI has no fragment identifier, then
the document has no target element.</p>

<div class="example">
 <p>Example:</p>
 <pre>p.note:target</pre>
 <p>This selector represents a <code>p</code> element of class
 <code>note</code> that is the target element of the referring
 URI.</p>
</div>

<div class="example">
 <p>CSS example:</p>
 <p>Here, the <code>:target</code> pseudo-class is used to make the
 target element red and place an image before it, if there is one:</p>
 <pre>*:target { color : red }
*:target::before { content : url(target.png) }</pre>
</div>

<h4><a name=lang-pseudo>6.6.3. The language pseudo-class :lang</a></h4>

<p>If the document language specifies how the human language of an
element is determined, it is possible to write selectors that
represent an element based on its language. For example, in HTML <a
href="#refsHTML4">[HTML4]</a>, the language is determined by a
combination of the <code>lang</code> attribute, the <code>meta</code>
element, and possibly by information from the protocol (such as HTTP
headers). XML uses an attribute called <code>xml:lang</code>, and
there may be other document language-specific methods for determining
the language.</p>

<p>The pseudo-class <code>:lang(C)</code> represents an element that
is in language C. Whether an element is represented by a
<code>:lang()</code> selector is based solely on the identifier C
being either equal to, or a hyphen-separated substring of, the
element's language value, in the same way as if performed by the <a
href="#attribute-representation">'|='</a> operator in attribute
selectors. The identifier C does not have to be a valid language
name.</p>

<p>C must not be empty. (If it is, the selector is invalid.)</p>

<p class="note"><strong>Note:</strong> It is recommended that
documents and protocols indicate language using codes from RFC 3066 <a
href="#refsRFC3066">[RFC3066]</a> or its successor, and by means of
"xml:lang" attributes in the case of XML-based documents <a
href="#refsXML10">[XML10]</a>. See <a
href="http://www.w3.org/International/questions/qa-lang-2or3.html">
"FAQ: Two-letter or three-letter language codes."</a></p>

<div class="example">
  <p>Examples:</p>
  <p>The two following selectors represent an HTML document that is in
  Belgian, French, or German. The two next selectors represent
  <code>q</code> quotations in an arbitrary element in Belgian, French,
  or German.</p>
  <pre>html:lang(fr-be)
html:lang(de)
:lang(fr-be) &gt; q
:lang(de) &gt; q</pre>
</div>

<h4><a name=UIstates>6.6.4. The UI element states pseudo-classes</a></h4>

<h5><a name=enableddisabled>The :enabled and :disabled pseudo-classes</a></h5>

<p>The <code>:enabled</code> pseudo-class allows authors to customize
the look of user interface elements that are enabled &mdash; which the
user can select or activate in some fashion (e.g. clicking on a button
with a mouse).  There is a need for such a pseudo-class because there
is no way to programmatically specify the default appearance of say,
an enabled <code>input</code> element without also specifying what it
would look like when it was disabled.</p>

<p>Similar to <code>:enabled</code>, <code>:disabled</code> allows the
author to specify precisely how a disabled or inactive user interface
element should look.</p>

<p>Most elements will be neither enabled nor disabled.  An element is
enabled if the user can either activate it or transfer the focus to
it. An element is disabled if it could be enabled, but the user cannot
presently activate it or transfer focus to it.</p>


<h5><a name=checked>The :checked pseudo-class</a></h5>

<p>Radio and checkbox elements can be toggled by the user. Some menu
items are "checked" when the user selects them. When such elements are
toggled "on" the <code>:checked</code> pseudo-class applies. The
<code>:checked</code> pseudo-class initially applies to such elements
that have the HTML4 <code>selected</code> and <code>checked</code>
attributes as described in <a
href="http://www.w3.org/TR/REC-html40/interact/forms.html#h-17.2.1">Section
17.2.1 of HTML4</a>, but of course the user can toggle "off" such
elements in which case the <code>:checked</code> pseudo-class would no
longer apply. While the <code>:checked</code> pseudo-class is dynamic
in nature, and is altered by user action, since it can also be based
on the presence of the semantic HTML4 <code>selected</code> and
<code>checked</code> attributes, it applies to all media.


<h5><a name=indeterminate>The :indeterminate pseudo-class</a></h5>

<div class="note">

<p>Radio and checkbox elements can be toggled by the user, but are
sometimes in an indeterminate state, neither checked nor unchecked.
This can be due to an element attribute, or DOM manipulation.</p>

<p>A future version of this specification may introduce an 
<code>:indeterminate</code> pseudo-class that applies to such elements.
<!--While the <code>:indeterminate</code> pseudo-class is dynamic in
nature, and is altered by user action, since it can also b